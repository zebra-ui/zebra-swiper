import{_ as i,b as a,a8 as e,o as t}from"./chunks/framework.BboaNvjl.js";const c=JSON.parse('{"title":"常见问题","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/faq.md","filePath":"guide/faq.md"}'),l={name:"guide/faq.md"};function n(p,s,h,o,d,k){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h1><h2 id="modules-not-working" tabindex="-1">关于模块引入样式后未生效的原因分析与解决方案 <a class="header-anchor" href="#modules-not-working" aria-label="Permalink to &quot;关于模块引入样式后未生效的原因分析与解决方案 {#modules-not-working}&quot;">​</a></h2><p>在 3.x 版本中，部分模块附带样式文件，但需要开发者手动引入这些样式。然而，当 <code>style</code> 标签的 <code>scoped</code> 属性启用时，样式隔离机制会生效，导致引入的模块样式被局部作用域限制，无法全局生效。这种情形可能会妨碍模块样式的正常应用。</p><p>为解决此问题，推荐以下两种方法：</p><h3 id="faq-style-allimport" tabindex="-1">方法一：全局引入样式（推荐） <a class="header-anchor" href="#faq-style-allimport" aria-label="Permalink to &quot;方法一：全局引入样式（推荐） {#faq-style-allimport}&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>全局引入与单独引入的代码体积无差别，更推荐全局引入。</p></div><p>通过在 <code>App.vue</code> 文件中全局引入样式，避免局部作用域的隔离问题。示例如下：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* App.vue */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lang=&quot;scss&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   @use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &quot;@/uni_modules/zebra-swiper/modules/navigation/navigation.scss&quot;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>此方式确保模块样式可以在整个项目范围内生效，无需额外配置。</p><h3 id="faq-style-twotags" tabindex="-1">方法二：分离 <code>style</code> 标签 <a class="header-anchor" href="#faq-style-twotags" aria-label="Permalink to &quot;方法二：分离 \`style\` 标签 {#faq-style-twotags}&quot;">​</a></h3><p>在需要使用模块样式的组件文件中，分别声明两个 <code>style</code> 标签：一个不启用样式隔离，专门用于模块样式引入；另一个启用样式隔离，用于组件的自定义样式。具体实现如下：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- index.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 自定义样式，启用样式隔离 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scss&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .demo {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 引入模块样式，不启用样式隔离 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scss&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @use &quot;@/uni_modules/zebra-swiper/modules/navigation/navigation.scss&quot;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="swiper-on-popup-error" tabindex="-1">小程序在弹窗 <code>popup</code> 中使用 <code>swiper</code> 时的加载问题 <a class="header-anchor" href="#swiper-on-popup-error" aria-label="Permalink to &quot;小程序在弹窗 \`popup\` 中使用 \`swiper\` 时的加载问题 {#swiper-on-popup-error}&quot;">​</a></h2><p>在小程序和 H5 中，弹窗<code>v-show</code>的加载机制存在显著差异。</p><p>小程序在页面加载时，即使弹窗未被显示，其内容也会被加载。然而，此时通过 <code>uni.createSelectorQuery()</code> 获取弹窗内容的宽高可能返回 <code>null</code>，导致 <code>swiper</code> 无法正常加载。</p><p>为了解决这一问题，可以通过配置 <code>width</code> 或 <code>height</code> 属性，预先为 <code>swiper</code> 设置固定的宽高值，从而确保其正常加载和渲染。</p><p>相关配置：<a href="/api/basic.html#width"><code>width</code></a> | <a href="/api/basic.html#height"><code>height</code></a></p>`,17)]))}const g=i(l,[["render",n]]);export{c as __pageData,g as default};
